#+TITLE: Emacs dotfiles
* Table of contents                                               :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#introduction][Introduction]]
- [[#helpers][Helpers]]
- [[#my-general-configs][My general configs]]
  - [[#evil-config][Evil config]]
  - [[#avy-config][Avy config]]
  - [[#which-key-config][Which key config]]
  - [[#shell-config][Shell config]]
  - [[#terminal-multi-libvterm-config][Terminal (multi-libvterm) config]]
  - [[#frame-config][Frame config]]
  - [[#clipboard-config][Clipboard config]]
  - [[#setup-theme-config][Setup theme config]]
  - [[#setup-editor-config][Setup editor config]]
  - [[#xdg-config][xdg config]]
- [[#my-search-configs][My search configs]]
  - [[#helm-config][Helm config]]
  - [[#neotree-config][Neotree config]]
  - [[#fzf-search-config][Fzf search config]]
- [[#my-edit-tools-configs][My edit tools configs]]
  - [[#flycheck-config][Flycheck config]]
  - [[#auto-complete-config][Auto complete config]]
  - [[#multi-cursors-config][Multi cursors config]]
- [[#my-git-tools-config][My git tools config]]
  - [[#magit-config][Magit config]]
  - [[#annotategit-blame][Annotate(Git blame)]]
  - [[#forge][Forge]]
- [[#my-ui-configs][My ui configs]]
  - [[#space-line-config][space line config]]
  - [[#indent-guide-config][indent guide config]]
  - [[#highlight-indent-guides-config][highlight-indent-guides config]]
- [[#other-tools-configs][Other tools configs]]
  - [[#language-server-protocol-lsp-mode][language server protocol (lsp-mode)]]
  - [[#workspacepersp-mode-config][workspace(PERSP MODE) config]]
  - [[#org-mode-config][org mode config]]
  - [[#ruby-mode-config][ruby mode config]]
  - [[#js-config][js config]]
  - [[#reason-mode-config][Reason mode config]]
#+END_QUOTE

* Introduction
  - Use "C-c ;" to toggle config items
  - Use "zc", "zo", "shift-tab" to expand and collapse config items
  - Use "C-x ns" and "C-x nw" to narrow or expand subtree items
  - Use "C-c '" inside lisp source to toggle edit config source code
  - Use "C-c C-b" to jump to the subtree header
* Helpers
  #+BEGIN_SRC emacs-lisp
    (defun create-shell ()
      "creates a shell with a given name"
      (interactive);; "Prompt\n shell name:")
      (let ((shell-name (read-string "shell name: " nil)))
        (shell (concat "*" shell-name "*"))))

    (defun z/open-emacs-config-file ()
      "Open the init file."
      (interactive)
      (progn
        (select-frame (new-frame))
        (find-file "~/workspace_mine/w_emacs_dotfiles/emacs.org")
        ))

    (defun create-shell-with-name (name)
      (shell (concat "*" name "*")))

    (defun z/show-message-log ()
      (interactive)
      (progn
        (select-frame (new-frame))
        (switch-to-buffer "*Messages*")))

    (defun s/show-buffer-file-path ()
      "Show the full path to the current file in the minibuffer."
      (interactive)
      (let ((file-name (buffer-file-name)))
        (if file-name
            (progn
              (message file-name)
              (kill-new file-name))
          (error "Buffer not visiting a file"))))

    (defalias 'z/absolute-path 's/show-buffer-file-path)

    (defun w/show-buffer-project-path ()
      "Show the full path to the current project in the minibuffer."
      (interactive)
      (let ((project-path (projectile-project-root)))
        (if project-path
            (progn
              (message project-path)
              (kill-new project-path))
          (error "Buffer not visiting a project"))))

    (defun s/show-buffer-file-name ()
      "Show the full path to the current file in the minibuffer."
      (interactive)
      (let ((file-name (file-name-nondirectory(buffer-file-name))))
        (if file-name
            (progn
              (message file-name)
              (kill-new file-name))
          (error "Buffer not visiting a file"))))

    (defun w/show-buffer-file-name-base ()
      "Show current file name base in the minibuffer."
      (interactive)
      (let ((file-name (file-name-base(buffer-file-name))))
        (if file-name
            (progn
              (message file-name)
              (kill-new file-name))
          (error "Buffer not visiting a file"))))

    (defun w/file-path-with-line ()
      "Retrieve the file path of the current buffer, including line number.

    Returns:
      - A string containing the file path in case of success.
      - `nil' in case the current buffer does not have a directory."
      (when-let (file-path (buffer-file-name))
        (concat file-path ":" (number-to-string (line-number-at-pos)))))

    (defun w/show-buffer-file-path-with-line ()
      "Show current file name base in the minibuffer."
      (interactive)
      (let ((file-name (w/file-path-with-line)))
        (if file-name
            (progn
              (message file-name)
              (kill-new file-name))
          (error "Buffer not visiting a file"))))

                                            ; Folding
    (defun toggle-selective-display (column)
      (interactive "P")
      (set-selective-display
       (or column
           (unless selective-display
             (1+ (current-column))))))

    (defun aj-toggle-fold ()
      "Toggle fold all lines larger than indentation on current line
      soutce: https://blog.chmouel.com/2016/09/07/dealing-with-yaml-in-emacs/"
      (interactive)
      (let ((col 1))
        (save-excursion
          (back-to-indentation)
          (setq col (+ 1 (current-column)))
          (set-selective-display
          (if selective-display nil (or col 1))))))

    (defun toggle-camelcase-underscores ()
      "Toggle between camelcase and underscore notation for the symbol at point."
      (interactive)
      (save-excursion
        (let* ((bounds (bounds-of-thing-at-point 'symbol))
               (start (car bounds))
               (end (cdr bounds))
               (currently-using-underscores-p (progn (goto-char start)
                                                     (re-search-forward "_" end t))))
          (if currently-using-underscores-p
              (progn
                (upcase-initials-region start end)
                (replace-string "_" "" nil start end)
                (downcase-region start (1+ start)))
            (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ start) end)
            (downcase-region start (cdr (bounds-of-thing-at-point 'symbol)))))))

    (defun toggle-camelcase-motion ()
      (interactive)
      (if (get 'camelcase-motion-toggle-flag 'state)
          (progn
            (message "Disabled camelcase motion")
            (subword-mode'-1)
            (put 'camelcase-motion-toggle-flag'state nil))
        (progn
          (message "Enabled camelcase motion")
          (subword-mode)
          (put 'camelcase-motion-toggle-flag 'state t))
        )
      )
  #+END_SRC
* My general configs
** Evil config
   #+BEGIN_SRC emacs-lisp
     (define-key isearch-mode-map (kbd "s-v") 'isearch-yank-kill)
     (setq evil-want-C-u-scroll t)
     (setq w/main-leader-key "SPC")
     (setq w/secondary-leader-key ",")
     (setq confirm-kill-emacs #'y-or-n-p) ; or yes-or-no-p is you're really paranoid
     (defun z/customize-syntax-table ()
       (interactive)
       (modify-syntax-entry ?- "w" (standard-syntax-table))
       (modify-syntax-entry ?- "w" (syntax-table))
       (modify-syntax-entry ?_ "w" (standard-syntax-table))
       (modify-syntax-entry ?_ "w" (syntax-table)))
     (defun z/customize-elisp-syntax-table ()
       (interactive)
       (modify-syntax-entry ?- "w")
       (modify-syntax-entry ?/ "w"))
     (defun z/customize-ruby-mode-table()
       (interactive)
       (modify-syntax-entry ?? "w")
       (modify-syntax-entry ?@ "w")
       (modify-syntax-entry ?! "w"))

     (add-hook 'after-change-major-mode-hook 'z/customize-syntax-table)
     (add-hook 'change-major-mode-hook 'z/customize-syntax-table)
     (add-hook 'emacs-lisp-mode-hook 'z/customize-elisp-syntax-table)
     (add-hook 'ruby-mode-hook 'z/customize-ruby-mode-table)

     ;; https://github.com/syl20bnr/spacemacs/issues/9740
     (with-eval-after-load 'evil (defalias #'forward-evil-word #'forward-evil-symbol))

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Evil
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (require 'evil-visualstar)
     (global-evil-visualstar-mode)
     (setq evil-visualstar/persistent t)

     (use-package general
       :config
       (require 'general)
       (general-evil-setup t)
       (general-override-mode)

       (general-define-key
        :states '(normal visual insert emacs)
        :prefix w/main-leader-key
        :keymaps 'override
        :non-normal-prefix "M-m"
                                             ;helm M-x
        "SPC" 'w/helm-M-x
                                             ;File
        "f" '(:ignore t :which-key "Files")
        "ff" 'helm-find-files
        "fy" '(:ignore t :which-key "yank path")
        "fyY" 'w/copy-relative-file-path
        "fyy" 's/show-buffer-file-path
        "fyn" 's/show-buffer-file-name
        "fyN" 'w/show-buffer-file-name-base
        "fyl" 'w/show-buffer-file-path-with-line
        "fyL" 'w/copy-relative-file-path-with-line
        "ft" 'neotree-project-dir-toggle
        "fw" 'save-buffer
        "fx" 'evil-quit
        "fe" '(:ignore t :which-key "emacs")
        "fes" 'z/sync-config
                                             ;Projects
        "p" '(:ignore t :which-key "projects")
        "pf" 'helm-projectile-find-file
        "pg" 'find-my-tag
        "pG" 'projectile-regenerate-tags
        "pD" 'w/projectile-dired
        "pr" 'projectile-recentf
        "pI" 'projectile-invalidate-cache
        "pp" 'w/projectile-switch-project
        "py" 'w/show-buffer-project-path
        "pl" 'w/ivy-persp-switch-project
                                             ;Search
        "s" '(:ignore t :which-key "search/symbol")
        "sf" 'helm-do-ag
        "sp" 'helm-do-ag-project-root
        "sa" '(:ignore t :which-key "ag")
        "saf" 'helm-do-ag
        "saa" 'helm-do-ag-this-file
                                             ;Toggle
        "t" '(:ignore t :which-key "toggles")
        "ti" 'indent-guide-toggle
        "ts" 'flycheck-toggle
        "tn" 'global-display-line-numbers-mode
        "tl" 'toggle-truncate-lines
        "tM" '(evil-mc-moe ':which-key "multi cursors(g r)")

        "t C-c" 'toggle-camelcase-motion
        "th" '(:ignore t :which-key "highlight")
        "thp" 'highlight-parentheses-mode
                                             ;Buffer
        "b" '(:ignore t :which-key "buffers")
        "bb" 'w/helm-mini
        "bR" 'evil-edit
                                             ;Zoom(Folding)
        "z" '(:ignore t :which-key "zoom")
        "zc" 'toggle-selective-display
                                             ;Applications
        "a" '(:ignore t :which-key "applications")
        "ad" 'dired
        "ap" 'list-processes
        "ai" '(:ignore t :which-key "System info")
        "ait" 'emacs-init-time
        "as" '(:ignore t :which-key "Shell")
        "asn" 'create-shell
                                             ;Git
        "g" '(:ignore t :which-key "Git")
        "gb" 'magit-blame
        "gB" 'vc-annotate
        "gm" 'magit-dispatch
        "gt" 'hydra-git-timemachine-on
        "gs" 'magit-status
        "gy" 'w/git-last-commit-message
        "gf" '(:ignore t :which-key "file")
        "gfh" 'magit-log-buffer-file
        "gfb" 'magit-log-all-branches
        "gl" '(:ignore t :which-key "links")
        "gll" 'git-link

        "y" 'repeat

        "k" '(:ignore t :which-key "super-k")
        "ks" 'neotree-project-dir-toggle
        "kfn" 's/show-buffer-file-name
        "kfr" 'w/copy-relative-file-path
        "kfa" 'z/absolute-path
        "kfl" 'w/copy-relative-file-path-with-line
        "kfo" 'xah-open-in-chrome
        "keh" 'z/eval-last-sexp
        "kee" 'z/eval-region
        "kex" 'xah-run-current-file
                                             ;Jump
        "j" '(:ignore t :which-key "jump")
        "jj" 'evil-avy-goto-char
        "jJ" 'evil-avy-goto-char-2
        "jl" 'evil-avy-goto-line
        "jw" 'evil-avy-goto-word-or-subword-1
                                             ;Error
        "e" '(:ignore t :which-key "errors")
        "ef" 'force-run-flycheck
        "el" 'flycheck-list-errors
        "en" 'next-error
        "eN" 'previous-error
        "ep" 'previous-error
        "ec" 'flycheck-clear
                                             ;Layouts
        "l" '(:ignore t :which-key "layouts")
        "lL" 'w/persp-load-state-from-file
        "ls" 'w/persp-save-state-to-file
                                             ;Regiters
        "r" '(:ignore t :which-key "registers")
        "rj" 'jump-to-register
        "rw" 'window-configuration-to-register
        "rl" 'helm-resume
        "rr" 'revert-buffer
                                             ;Windows
        "w" '(:ignore t :which-key "windows")
        "w=" 'balance-windows
        "wr" 'w/rotate-windows-forward
        "wR" 'w/rotate-windows-backward
        "w/" 'z/split-window-right
        "w-" 'z/split-window-below
        "wv" 'z/split-window-right
        "ws" 'z/split-window-below
        "wd" 'delete-window
        "wm" 'toggle-maximize-buffer
        "wj" 'tmux-navigate-down
        "wk" 'tmux-navigate-up
        "wh" 'tmux-navigate-left
        "wl" 'tmux-navigate-right
        "wc" 'evil-window-delete
        "wF" 'w/make-frame
        "wo" 'other-frame
        "wO" 'select-frame-number
        "ww" 'evil-window-delete
        "w C-m" 'toggle-frame-maximized
                                             ;Text
        "x" '(:ignore t :which-key "text")
        "xU" 'upcase-region
        "xu" 'downcase-region
        "xs" 'toggle-camelcase-underscores
        "xd" '(:ignore t :which-key "delete")
        "xdw" 'delete-trailing-whitespace
        )

       (defun z/split-window-right ()
         (interactive)
         (split-window-right)
         (other-window 1)
         )
       (defun z/split-window-below ()
         (interactive)
         (split-window-below)
         (other-window 1)
         )

       ;;Mapping for ruby mode
       (defun w/remap-ruby-mode-leader-key ()
         (interactive)
         (which-key-add-key-based-replacements ",t" "ruby/test")
         )
       (add-hook 'ruby-mode-hook 'w/remap-ruby-mode-leader-key)

       (general-define-key
        :states '(normal visual emacs)
        "C-w +" '((lambda () (interactive) (evil-window-increase-height 15)) :which-key "window-increase-height")
        "C-w -" '((lambda () (interactive) (evil-window-decrease-height 15)) :which-key "window-decrease-height")
        "C-w >" '((lambda () (interactive) (evil-window-increase-width 15)) :which-key "window-increase-width")
        "C-w <" '((lambda () (interactive) (evil-window-decrease-width 15)) :which-key "window-decrease-width")
        "C-w r" 'w/rotate-windows-forward
        "C-w R" 'w/rotate-windows-backward
        "C-w m" 'toggle-maximize-buffer
        "C-w v" 'z/split-window-right
        "C-w s" 'z/split-window-below "tab" 'evil-avy-goto-word-or-subword-1
        )

       (defun z/cut-text-region(beg end)
        (interactive "r")
        (evil-yank beg end)
        (evil-delete-char beg end))

       (general-define-key
        :states '(normal visual)
        "X" 'z/cut-text-region
        )

       (general-define-key
        :states '(normal visual emacs insert)
        "M-d" 'evil-delete-backward-word
        "M-DEL" 'evil-delete-backward-word
        )

       (evil-define-motion evil-next-close-bracket (count)
         "Go to [count] next unmatched ']'."
         :type exclusive
         (forward-char)
         (evil-up-paren ?\[ ?\] (or count 1))
         (backward-char))

       (evil-define-motion evil-previous-open-bracket (count)
         "Go to [count] previous unmatched '['."
         :type exclusive
         (evil-up-paren ?\[ ?\] (- (or count 1))))

       (general-define-key
        :states '(normal visual emacs)
        "H" 'evil-digit-argument-or-evil-beginning-of-line
        "L" 'evil-end-of-line

        "g(" 'evil-previous-open-paren
        "g{" 'evil-previous-open-brace
        "g[" 'evil-previous-open-bracket
        "g)" 'evil-next-close-paren
        "g}" 'evil-next-close-brace
        "g]" 'evil-next-close-bracket
        "gdd" 'evil-goto-definition
        "gdv" '(lambda () (interactive) (z/split-window-right) (evil-goto-definition))
        "gds" '(lambda () (interactive) (z/split-window-below) (evil-goto-definition))

        ;; map to be like tmux
        "C-a h" 'tmux-navigate-left
        "M-h" 'tmux-navigate-left
        "C-a j" 'tmux-navigate-down
        "M-j" 'tmux-navigate-down
        "C-a k" 'tmux-navigate-up
        "M-k" 'tmux-navigate-up
        "C-a l" 'tmux-navigate-right
        "M-l" 'tmux-navigate-right
        "C-a x" 'evil-quit
        "C-a m" 'toggle-maximize-buffer
        "C-a r" 'w/rotate-windows-forward
        "C-a R" 'w/rotate-windows-backward
        "C-a C-o" 'w/rotate-windows-backward
        "C-a c" 'w/make-frame
        "C-a +" 'new-frame
        "C-a -" 'z/split-window-below
        "C-a s" 'z/split-window-below
        "C-a _" 'z/split-window-right
        "C-a v" 'z/split-window-right
        "C-a =" 'balance-windows

        ;; single super key mappings
        ;;"s-p" 'fzf
        "s-Q" 'save-buffers-kill-emacs
        "s-+" 'new-frame
        "s-p" 'helm-projectile-find-file
        "s-P" 'w/helm-M-x
        "s-w" 'evil-window-delete
        "s-W" 'evil-quit
        "s-s" 'save-buffer
        "s-j" 'evil-avy-goto-word-or-subword-1
        "s-d" 'kill-whole-line
        "s-f" 'evil-search-forward
        "s-g" 'evil-search-word-forward
        "s-G" 'evil-search-word-backward
        "s-F" 'helm-do-ag-project-root
        "s-n s-s" 'evil-window-new
        "s-n s" 'evil-window-new
        "s-n s-v" 'evil-window-vnew
        "s-n v" 'evil-window-vnew
        "s-N" 'w/make-frame
        "s-R" 'delete-trailing-whitespace
        "s-O" 'select-frame-number
        "s-/" 'evilnc-comment-or-uncomment-lines
        "s-l" 'evil-avy-goto-line
        "s-t h" 'helm-imenu
        "s-t t" 'lsp-ui-imenu
        "s-t l" 'toggle-truncate-lines
        "s-t a" 'toggle-transparency
        "s-=" 'balance-windows
        "s-m" 'toggle-maximize-buffer
        "s-b" 'helm-resume
        "s-y" 'repeat

        ;; navigation
        "M-[" 'evil-jump-backward
        "M-]" 'evil-jump-forward
        "<s-return>" 'evil-goto-definition

        ;; combination with super+k
        "s-k s-g c" 'hydra-smerge/body
        "s-k s-g s-c" 'hydra-smerge/body
        "s-k s-g g" 'magit-status ;status here
        "s-k s-g s-g" 'magit-status ;status here
        "s-k s-g n" 'z/magit-status ;status in new frame
        "s-k s-g s-n" 'z/magit-status ;status in new frame
        "s-k s-s"   'neotree-project-dir-toggle

        "s-k s-f n" 's/show-buffer-file-name
        "s-k s-f s-n" 's/show-buffer-file-name
        "s-k s-f r"   'w/copy-relative-file-path
        "s-k s-f s-r" 'w/copy-relative-file-path
        "s-k s-f a"    'z/absolute-path
        "s-k s-f s-a"  'z/absolute-path
        "s-k s-f l"   'w/copy-relative-file-path-with-line
        "s-k s-f s-l" 'w/copy-relative-file-path-with-line
        "s-k s-f o" 'xah-open-in-chrome
        "s-k s-f s-o" 'xah-open-in-chrome
        "s-k s-f f" 'z/which-function
        "s-k s-f s-f" 'z/which-function
        "s-k s-[" 'aj-toggle-fold

        "s-k s-e s" 'shell-command
        "s-k s-e s-s" 'shell-command
        "s-k s-e h" 'z/eval-last-sexp
        "s-k s-e s-h" 'z/eval-last-sexp
        "s-k s-e e" 'z/eval-region
        "s-k s-e s-e" 'z/eval-region

        "s-k s-w" 'toggle-truncate-lines
        "s-k s-i" 's/show-buffer-file-name

        "s-k s-r c" 'z/sync-config
        "s-k s-r r" 'revert-buffer

        "s-k s-j" 'git-gutter:next-hunk
        "s-k s-k" 'git-gutter:previous-hunk

        ;;"s-1" 'customize ;;before, it is "s-,"
        "s-0" '(lambda () (interactive) (neotree-hide) (neotree-project-dir-toggle) (neotree-quick-look))
        "s-, s-," 'z/open-emacs-config-file
        "s-. s-." 'z/show-message-log

        ;; 3 key stroke with super
        "<C-s-268632087>" 'delete-other-windows
        "<C-s-268632079>" 'w/projectile-switch-project-in-new-frame ;; super+ctrl+o
        "<C-s-268632080>" 'w/projectile-switch-project
        "C-s-o" 'w/projectile-switch-project-in-new-frame ;; super+ctrl+o
        "C-s-p" 'w/projectile-switch-project ;; super+ctrl+p
        )

       ; emacs-linux
       (define-key global-map [?\s-x] 'kill-region)
       (define-key global-map [?\s-c] 'kill-ring-save)
       (define-key global-map [?\s-v] 'yank)
       (define-key global-map [?\s-a] 'mark-whole-buffer)

       (general-define-key
        :states '(normal visual insert emacs)
        :prefix w/secondary-leader-key
        :non-normal-prefix "M-n"
        :keymaps 'ruby-mode-map
        "i" '(:ignore t :which-key "inf")
        "ia" 'inf-ruby-console-auto
        "t" '(:ignore t :which-key "ruby/test")
        "tb" 'ruby-test-run
        "tt" 'ruby-test-run-at-point
        "ts" '(ruby-test-toggle-implementation-and-specification :which-key "Ruby test toggle")
        )
       ;;Mapping for dired mode
       (defun w/remap-dired-mode-leader-key ()
         (interactive)
         (which-key-add-key-based-replacements ",t" "toggles")
         )
       (add-hook 'dired-hook 'w/remap-dired-mode-leader-key)
       (general-define-key
        :states '(normal visual insert emacs)
        :prefix w/secondary-leader-key
        :non-normal-prefix "M-n"
        :keymaps 'dired-mode-map
        "," 'dired-up-directory
        "u" '(dired-unmark :which-key "unmark(u)")
        "m" '(dired-mark :which-key "mark(m)")
        "r" '(revert-buffer-no-confirm :which-key "refresh(r)")
        "j" 'dired-next-subdir
        "k" 'dired-prev-subdir
        "h" 'w/dired-go-to-home-folder
        "f" 'helm-find-files
        "F" 'find-name-dired
                                             ;Actions
        "a" '(:ignore t :which-key "Actions")
        "af" '(:ignore t :which-key "Files")
        "afn" '(find-file :which-key "Create file")
        "afN" 'dired-create-directory
        "afr" '(dired-do-rename :which-key "Rename(Shift + r)")
        "afd" '(dired-do-delete :which-key "Delete(Shift + d)")
        "ae" '(:ignore t :which-key "Edit")
        "aex" '(dired-copy-paste-do-cut :which-key "Cut")
        "aec" '(dired-copy-paste-do-copy :which-key "Copy")
        "aep" '(dired-copy-paste-do-paste :which-key "Paste")
                                             ;Toggle
        "T" '(:ignore t :which-key "toggles")
        "Td" 'dired-hide-details-mode
        )
       )

     (use-package evil
       :config
       (require 'evil)
       (evil-mode t)
       (define-key evil-motion-state-map (kbd "C-u") 'evil-scroll-up)

       ; hover through visual line
       ; https://github.com/syl20bnr/spacemacs/issues/9557
       ; or https://github.com/noctuid/evil-guide#global-keybindings-and-evil-states
       (define-key evil-normal-state-map "j" 'evil-next-visual-line)
       (define-key evil-normal-state-map "k" 'evil-previous-visual-line)
       (define-key evil-visual-state-map "j" 'evil-next-visual-line)
       (define-key evil-visual-state-map "k" 'evil-previous-visual-line)
       (with-eval-after-load "dired" ;"dired mapping"
         ;; vimify some keybinds.
         (define-key dired-mode-map (kbd "j") #'dired-next-line)
         (define-key dired-mode-map (kbd "k") #'dired-previous-line)
         (define-key dired-mode-map (kbd "n") #'evil-search-next)
         (define-key dired-mode-map (kbd "N") #'evil-search-previous))

       (use-package evil-surround
         :config
         (progn
           (global-evil-surround-mode 1)
           (add-to-list 'evil-surround-operator-alist '(evil-cp-change . change))
           (add-to-list 'evil-surround-operator-alist '(evil-cp-delete . delete))))
       )

     ;; evil-nerd-commenter
     (use-package evil-nerd-commenter
       :init
       (with-eval-after-load "evil"
         (define-key evil-visual-state-map "gc" 'evilnc-comment-or-uncomment-lines)
         (define-key evil-normal-state-map "gc" 'evilnc-comment-or-uncomment-lines)
         ))


     ;;Rotate windows
     (defun w/rotate-windows-forward (count)
       "Rotate each window forwards.
        A negative prefix argument rotates each window backwards.
        Dedicated (locked) windows are left untouched."
       (interactive "p")
       (let* ((non-dedicated-windows (cl-remove-if 'window-dedicated-p (window-list)))
              (states (mapcar #'window-state-get non-dedicated-windows))
              (num-windows (length non-dedicated-windows))
              (step (+ num-windows count)))
         (if (< num-windows 2)
             (error "You can't rotate a single window!")
           (dotimes (i num-windows)
             (window-state-put
              (elt states i)
              (elt non-dedicated-windows (% (+ step i) num-windows)))))))

     (defun w/rotate-windows-backward (count)
       "Rotate each window backwards.
        Dedicated (locked) windows are left untouched."
       (interactive "p")
       (w/rotate-windows-forward (* -1 count)))

     ;; from https://gist.github.com/3402786
     (defun toggle-maximize-buffer ()
       "Maximize buffer"
       ;; https://github.com/syl20bnr/spacemacs/issues/8107
       (interactive)
       (if (let ((window-count (length (window-list))))
             (and
              (or ( = 1 window-count)
                  (and
                   ( = 2 window-count)
                   (neo-global--window-exists-p)))
              (assoc ?_ register-alist)))
           (jump-to-register ?_)
         (progn
           (window-configuration-to-register ?_)
           (delete-other-windows))))

     (defun z/sync-config ()
       (interactive)
       (if (y-or-n-p "Sync emacs config ?")
           (progn (load-file user-init-file))))

     (defun find-my-tag ()
       (interactive)
       (if (not(fboundp 'my-find-tag-and-load-config))
           (progn
             (load "my-tags-config")
             (my-find-tag-and-load-config))
         (my-find-tag-and-load-config))
       )


                                             ;========================================================
                                             ; SETUP DIRED
                                             ;========================================================
     ;; Source: http://www.emacswiki.org/emacs-en/download/misc-cmds.el
     (defun revert-buffer-no-confirm ()
       "Revert buffer without confirmation."
       (interactive)
       (revert-buffer :ignore-auto :noconfirm))

     (defun w/dired-go-to-home-folder ()
       (interactive)
       (if (not(string= "~/" default-directory))
           (find-alternate-file "~/")
         )
       )

     (defun dired-copy-paste-do-cut ()
       "In dired-mode, cut a file/dir on current line or all marked file/dir(s)."
       (interactive)
       (setq dired-copy-paste-stored-file-list (dired-get-marked-files)
             dired-copy-paste-func 'rename-file)
       (message
        (format "%S is/are cut."dired-copy-paste-stored-file-list)))


     (defun dired-copy-paste-do-copy ()
       "In dired-mode, copy a file/dir on current line or all marked file/dir(s)."
       (interactive)
       (setq dired-copy-paste-stored-file-list (dired-get-marked-files)
             dired-copy-paste-func 'copy-file)
       (message
        (format "%S is/are copied."dired-copy-paste-stored-file-list)))


     (defun dired-copy-paste-do-paste ()
       "In dired-mode, paste cut/copied file/dir(s) into current directory."
       (interactive)
       (let ((stored-file-list nil))
         (dolist (stored-file dired-copy-paste-stored-file-list)
           (condition-case nil
               (progn
                 (funcall dired-copy-paste-func stored-file (dired-current-directory) 1)
                 (push stored-file stored-file-list))
             (error nil)))
         (if (eq dired-copy-paste-func 'rename-file)
             (setq dired-copy-paste-stored-file-list nil
                   dired-copy-paste-func nil))
         (revert-buffer)
         (message
          (format "%d file/dir(s) pasted into current directory." (length stored-file-list)))))
   #+END_SRC
** Avy config
   #+BEGIN_SRC emacs-lisp
   (setq avy-background t)
   #+END_SRC
** Which key config
   #+BEGIN_SRC emacs-lisp
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Which key
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (use-package which-key
      :commands (which-key-configs-load)
      :config
      (defun which-key-configs-load ()
        t)
      (run-with-timer 3 nil
                      (lambda ()
                        (message "Loading which-key configs...")))
      (require 'which-key)
      (require 'tramp)
      (which-key-mode)
      (which-key-setup-side-window-bottom)
      )

    (add-hook 'emacs-startup-hook 'which-key-configs-load)
   #+END_SRC

** Shell config
   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook
               (lambda ()
                 ;;Prevent backspace from deleting my shell prompt
                 (setq comint-prompt-read-only t)
                 ;;Go to the end of buffer to input when switching to insert mode
                 (add-hook 'evil-insert-state-entry-hook 'w/go-to-the-last-shell-prompt-maybe nil t)
                 (evil-define-key 'normal comint-mode-map (kbd "o") 'w/go-to-the-last-shell-prompt-maybe)
                 (evil-define-key 'normal comint-mode-map (kbd "p") 'w/shell-evil-paste-after)
                 ))
     (add-hook 'comint-mode-hook
               (lambda ()
                 (toggle-truncate-lines -1) ;;Enable auto line wrapping
                 (define-key comint-mode-map (kbd "<up>") 'comint-previous-input)
                 (define-key comint-mode-map (kbd "<down>") 'comint-next-input)
                 (evil-define-key 'normal comint-mode-map (kbd "C-d") 'evil-scroll-down)
                 ))

     ;; evil-paste-after for shell mode
     (defun w/shell-evil-paste-after ()
       (interactive)
       (w/go-to-the-last-shell-prompt-maybe)
       (call-interactively 'evil-paste-after)
     )

     ;;Go to the end of buffer to input when point is before the prompt.
     (defun w/go-to-the-last-shell-prompt-maybe ()
       (interactive)
       (let ((proc (get-buffer-process (current-buffer))))
         (if (not(and proc (>= (point) (marker-position (process-mark proc)))))
           (goto-char (point-max)))))

     ;;Prevent RET sending input from anywhere
     (defun w/my-comint-send-input-maybe ()
       "Only `comint-send-input' when point is after the latest prompt.
     Otherwise move to the end of the buffer."
       (interactive)
       (let ((proc (get-buffer-process (current-buffer))))
         (if (and proc (>= (point) (marker-position (process-mark proc))))
             (comint-send-input)
           (goto-char (point-max)))))

     (with-eval-after-load "comint"
       (define-key shell-mode-map [remap comint-send-input] 'w/my-comint-send-input-maybe))

     ;;ansi-term for tmux server
     (eval-after-load "term"
       '(progn
          (general-define-key
           :states '(insert)
           :keymaps 'term-raw-map
           "C-y c" '((lambda () (interactive) (term-send-raw-string "\C-yc")) :which-key "_")
           "C-y d" '((lambda () (interactive) (term-send-raw-string "\C-yd")) :which-key "_")
           "C-y x" '((lambda () (interactive) (term-send-raw-string "\C-yx")) :which-key "_")
           "C-y s" '((lambda () (interactive) (term-send-raw-string "\C-ys")) :which-key "_")
           "C-y $" '((lambda () (interactive) (term-send-raw-string "\C-y$")) :which-key "_")
           "C-y n" '((lambda () (interactive) (term-send-raw-string "\C-yn")) :which-key "_")
           "C-y p" '((lambda () (interactive) (term-send-raw-string "\C-yp")) :which-key "_")
           "j" '((lambda () (interactive) (term-send-raw-string "j")) :which-key "_")
           "k" '((lambda () (interactive) (term-send-raw-string "k")) :which-key "_")
           "C-y 1" '((lambda () (interactive) (term-send-raw-string "\C-y1")) :which-key "_")
           "C-y 2" '((lambda () (interactive) (term-send-raw-string "\C-y2")) :which-key "_")
           "C-y 3" '((lambda () (interactive) (term-send-raw-string "\C-y3")) :which-key "_")
           "C-y 4" '((lambda () (interactive) (term-send-raw-string "\C-y4")) :which-key "_")
           "<backspace>" '((lambda () (interactive) (term-send-raw-string "\C-h")) :which-key "_")
           "y" '((lambda () (interactive) (term-send-raw-string "y")) :which-key "_")
           "n" '((lambda () (interactive) (term-send-raw-string "n")) :which-key "_")
           )))

   #+END_SRC
** Terminal (multi-libvterm) config
   #+BEGIN_SRC emacs-lisp
   #+END_SRC
** Frame config
   - Frame configs to support switching workspace
   #+BEGIN_SRC emacs-lisp
     ;; Projectile project name as frame title
     ; https://emacs.stackexchange.com/a/3017
     (add-to-list 'initial-frame-alist '(fullscreen . maximized))
     (add-to-list 'default-frame-alist '(fullscreen . maximized))
     (setq frame-title-format
           '((:eval (if (buffer-file-name)
                        (abbreviate-file-name (buffer-file-name))
                      "%b")))
           )

    ;; winner mode setup
    (when (fboundp 'winner-mode)
      (winner-mode 1))
    (general-define-key
      :states '(normal visual insert emacs)
      "s-T"   'winner-undo
      "C-c j" 'winner-undo
      "C-c k" 'winner-redo)

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; winum-mode setup
     ;; https://github.com/deb0ch/emacs-winum
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; cause we using spaceline, we need to disable winum to insert to mode-line
     ;; https://github.com/TheBB/spaceline
     (setq winum-auto-setup-mode-line nil)
     (general-define-key
      :states '(normal visual insert emacs)
      "s-1" 'winum-select-window-1
      "s-2" 'winum-select-window-2
      "s-3" 'winum-select-window-3
      "s-4" 'winum-select-window-4
      "s-5" 'winum-select-window-5
      "s-6" 'winum-select-window-6
      "s-7" 'winum-select-window-7
      "s-8" 'winum-select-window-8
      "s-9" 'winum-select-window-9)
    (require 'winum)
    (winum-mode)
    (defun winum-assign-0-to-neotree ()
      (when (string-match-p (buffer-name) ".*\\*NeoTree\\*.*") 10))
    (add-to-list 'winum-assign-functions #'winum-assign-0-to-neotree)
    (setq window-numbering-scope            'global
          winum-reverse-frame-list          nil
          winum-auto-assign-0-to-minibuffer t
          winum-assign-func                 'my-winum-assign-func
          winum-auto-setup-mode-line        nil
          winum-format                      " %s "
          winum-mode-line-position          1
          winum-ignored-buffers             '(" *which-key*"))
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; end of winum-mode setup
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (defun toggle-window-split ()
      (interactive)
      (if (= (count-windows) 2)
          (let* ((this-win-buffer (window-buffer))
          (next-win-buffer (window-buffer (next-window)))
          (this-win-edges (window-edges (selected-window)))
          (next-win-edges (window-edges (next-window)))
          (this-win-2nd (not (and (<= (car this-win-edges)
              (car next-win-edges))
                (<= (cadr this-win-edges)
              (cadr next-win-edges)))))
          (splitter
            (if (= (car this-win-edges)
            (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
      (delete-other-windows)
      (let ((first-win (selected-window)))
        (funcall splitter)
        (if this-win-2nd (other-window 1))
        (set-window-buffer (selected-window) this-win-buffer)
        (set-window-buffer (next-window) next-win-buffer)
        (select-window first-win)
        (if this-win-2nd (other-window 1))))))
    (define-key ctl-x-4-map "t" 'toggle-window-split)

    ; Text-mode is default mode: https://groups.google.com/forum/#!topic/gnu.emacs.help/AUpnVjsSpfc
    (setq-default major-mode 'text-mode)

     ;; (setq frame-title-format
     ;;       '(""
     ;;         "%b"
     ;;         (:eval
     ;;          (let ((project-name (projectile-project-name))
     ;;                (persp-name (safe-persp-name (get-current-persp)))
     ;;                )
     ;;            (unless (string= "-" project-name)
     ;;              (format " in [%s] - persp [%s]" project-name persp-name))))))

     (defface frame-number-face
       '((t (:background "black" :foreground "red" )))
       "Face for `frame-number-face`."
       :group 'frame-fn)

     (defface frame-name-face
       '((t ( :background "black" :foreground "ForestGreen")))
       "Face for `frame-name-face`."
       :group 'frame-fn)

     (defun select-frame-number ()
       "Select a frame by number -- a maximum of 9 frames are supported."
       (interactive)
       (let* (
              choice
              chosen-frame
              (n 0)
              (frame-list (frame-list))
              (total-frames (safe-length frame-list))
              (frame-name-list
               (mapcar
                (lambda (frame) (cons frame (frame-parameter frame 'name)))
                frame-list))
              (frame-name-list-sorted
               (sort
                frame-name-list
                #'(lambda (x y) (string< (cdr x) (cdr y)))))
              (frame-number-list
               (mapcar
                (lambda (frame)
                  (setq n (1+ n))
                  (cons n (cdr frame)))
                frame-name-list-sorted))
              (pretty-list
               (mapconcat 'identity
                          (mapcar
                           (lambda (x) (concat
                                        "["
                                        (propertize (format "%s" (car x)) 'face 'frame-number-face)
                                        "] "
                                        (propertize (format "%s" (cdr x)) 'face 'frame-name-face)))
                           frame-number-list)
                          " | "))  )
         (message "%s" pretty-list)
         (setq choice (read-char-exclusive))
         (cond
          ((eq choice ?1)
           (setq choice 1))
          ((eq choice ?2)
           (setq choice 2))
          ((eq choice ?3)
           (setq choice 3))
          ((eq choice ?4)
           (setq choice 4))
          ((eq choice ?5)
           (setq choice 5))
          ((eq choice ?6)
           (setq choice 6))
          ((eq choice ?7)
           (setq choice 7))
          ((eq choice ?8)
           (setq choice 8))
          ((eq choice ?9)
           (setq choice 9))
          (t
           (setq choice 10)))
         (setq chosen-frame (car (nth (1- choice) frame-name-list-sorted)))
         (when (> choice total-frames)
           (let* (
                  (debug-on-quit nil)
                  (quit-message
                   (format "You must select a number between 1 and %s." total-frames)))
             (signal 'quit `(,quit-message ))))
         (select-frame chosen-frame)
         (raise-frame chosen-frame)
         chosen-frame)
       )
   #+END_SRC
** Clipboard config
  #+BEGIN_SRC emacs-lisp
    (if (not(display-graphic-p))
        (progn
          (osx-clipboard-mode +1)
          (setq x-select-enable-clipboard t)
          (setq x-select-enable-primary t)
          )
      )

    ;; https://github.com/syl20bnr/spacemacs/issues/6977#issuecomment-244014379
    (defun z/evil-delete (orig-fn beg end &optional type _ &rest args)
      (apply orig-fn beg end type ?_ args))
    (advice-add 'evil-delete :around 'z/evil-delete)
  #+END_SRC
** Setup theme config
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (format "%s/themes" w-dotfiles-folder-path))
     (add-to-list 'custom-theme-load-path (format "%s/themes" w-dotfiles-folder-path))
     (load-theme 'monokai t)
     (set-face-attribute 'region nil :background "#666")

     ;; (load-theme 'gruvbox-dark-medium t)
     ;; (load-theme 'dracula t)
   #+END_SRC
** Setup editor config
   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode 1)

     ;; welcome screen splash image
     (setq fancy-splash-image (format "%s/logo.png" w-dotfiles-folder-path))
     ;;ensure environment variables inside Emacs look the same as in the user's shell
     (when (memq window-system '(mac ns x))
       (exec-path-from-shell-initialize))
     ;;Only type y instead of yes
     (defalias 'yes-or-no-p 'y-or-n-p)
     ;;Disable auto line wrapping
     (set-default 'truncate-lines t)
     ;; Theme colors for shell
     (set-face-attribute 'comint-highlight-prompt nil
                         :inherit nil)
     (menu-bar-mode -1)
     ;; hide toolbar in emacs GUI
     (tool-bar-mode -1)
     (define-globalized-minor-mode global-highlight-parentheses-mode
       highlight-parentheses-mode
       (lambda ()
         (highlight-parentheses-mode t)))
     (global-highlight-parentheses-mode t)
     (global-auto-revert-mode 1)
     (add-hook 'dired-mode-hook 'auto-revert-mode)
     (defun w/setup-font-and-window ()
       (progn
         ;;Font size 13pt
         ;(set-face-attribute 'default nil :font "Inconsolata for Powerline" )
         (menu-bar-mode -1)
         ;;Disable scrollbar in UI mode
         (tool-bar-mode -1)
         (scroll-bar-mode -1)))
     (if (display-graphic-p) (w/setup-font-and-window))
     (defun contextual-menubar (&optional frame)
       "Display the menubar in FRAME (default: selected frame) if on a
              graphical display, but hide it if in terminal."
       (interactive)
       (if (display-graphic-p frame)
           (w/setup-font-and-window)
         )
       (set-frame-parameter frame 'menu-bar-lines
                            (if (display-graphic-p frame)
                                1 0)))

     ;; Hide meubar when opening emacs with emacs client
     (add-hook 'after-make-frame-functions 'contextual-menubar)

     ;; scroll one line at a time (less "jumpy" than defaults)
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
     (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
     (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

     ;; Moving cursor down at bottom scrolls only a single line, not half page
     (setq scroll-step 1) ;; keyboard scroll one line at a time
     (setq scroll-conservatively 5)
     ;; Indent
     (setq custom-tab-width 2)
     (setq-default indent-tabs-mode nil)
     (setq-default tab-width 2)
     (setq-default evil-shift-width 2)

     ;;;;;;;;;;;; some borrow emacs config ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; https://dougie.io/emacs/indentation/
     ;; Making electric-indent behave sanely
     (setq-default electric-indent-inhibit t)

     ;; Make the backspace properly erase the tab instead of
     ;; removing 1 space at a time.
     (setq backward-delete-char-untabify-method 'hungry)

     ;; (OPTIONAL) Shift width for evil-mode users
     ;; For the vim-like motions of ">>" and "<<".
     (setq-default evil-shift-width custom-tab-width)

     ;; WARNING: This will change your life
     ;; (OPTIONAL) Visualize tabs as a pipe character - "|"
     ;; This will also show trailing characters as they are useful to spot.
     (setq whitespace-style '(face tabs tab-mark trailing))
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (global-visual-line-mode t)
     (setq-default standard-indent 2)
     (setq-default js-indent-level 2)
     (setq json-reformat:indent-width 2)
     (setq x-path-walker-verbose t)
     (define-key evil-insert-state-map (kbd "TAB") 'tab-to-tab-stop)
     ;;Disable lock file
     ;;Emacs automatically creates a temporary symlink in the same directory as the file being edited
     ;; reload TAGS file automatically
     (setq tags-revert-without-query 1)
     ;; always follow symlink controlled by Git -- don't ask while writing ~/.zshrc file
     (setq vc-follow-symlinks t)
     (setq create-lockfiles nil)
     ;; Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.
     (custom-set-variables
      ;; custom-set-variables was added by Custom.
      ;; If you edit it by hand, you could mess it up, so be careful.
      ;; Your init file should contain only one such instance.
      ;; If there is more than one, they won't work right.
      '(auto-save-file-name-transforms (quote ((".*" "~/.emacs.d/autosaves/\\1" t))))
      '(backup-directory-alist (quote ((".*" . "~/.emacs.d/backups/"))))
      '(package-selected-packages
        (quote
         (evil-leader evil which-key helm-ag helm-projectile autothemer))))

     ;; create the autosave dir if necessary, since emacs won't.
     (make-directory "~/.emacs.d/autosaves/" t)
     ;; support downcase upcase
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC
** xdg config
   #+BEGIN_SRC emacs-lisp

    (defun xah-run-current-file ()
      "Execute the current file.
       For example, if the current buffer is the file x.py, then it'll call 「python x.py」 in a shell.
       The file can be Emacs Lisp, PHP, Perl, Python, Ruby, JavaScript, Bash, Ocaml, Visual Basic, TeX, Java, Clojure.
       File suffix is used to determine what program to run.

       If the file is modified or not saved, save it automatically before run.

       URL `http://ergoemacs.org/emacs/elisp_run_current_file.html'
       version 2016-01-28"
      (interactive)
      (let (
            (-suffix-map
              ;; (‹extension› . ‹shell program name›)
              `(
                ("php" . "php")
                ("pl" . "perl")
                ("py" . "python")
                ("py3" . ,(if (string-equal system-type "windows-nt") "c:/Python32/python.exe" "python3"))
                ("rb" . "ruby")
                ("go" . "go run")
                ("js" . "node") ; node.js
                ("sh" . "bash")
                ("clj" . "java -cp /home/xah/apps/clojure-1.6.0/clojure-1.6.0.jar clojure.main")
                ("rkt" . "racket")
                ("ml" . "ocaml")
                ("vbs" . "cscript")
                ("tex" . "pdflatex")
                ("latex" . "pdflatex")
                ("java" . "javac")
                ;; ("pov" . "/usr/local/bin/povray +R2 +A0.1 +J1.2 +Am2 +Q9 +H480 +W640")
                ))

            -fname
            -fSuffix
            -prog-name
            -cmd-str)

        (when (null (buffer-file-name)) (save-buffer))
        (when (buffer-modified-p) (save-buffer))

        (setq -fname (buffer-file-name))
        (setq -fSuffix (file-name-extension -fname))
        (setq -prog-name (cdr (assoc -fSuffix -suffix-map)))
        (setq -cmd-str (concat -prog-name " \""   -fname "\""))

        (cond
        ((string-equal -fSuffix "el") (load -fname))
        ((string-equal -fSuffix "java")
          (progn
            (shell-command -cmd-str "*xah-run-current-file output*" )
            (shell-command
            (format "java %s" (file-name-sans-extension (file-name-nondirectory -fname))))))
        (t (if -prog-name
                (progn
                  (message "Running…")
                  (shell-command -cmd-str "*xah-run-current-file output*" ))
              (message "No recognized program file suffix for this file."))))))
    (global-set-key (kbd "s-k s-e s-x") 'xah-run-current-file)
    (global-set-key (kbd "s-k s-e x") 'xah-run-current-file)


    (defun xah-open-in-chrome ()
    "Open the current file or `dired' marked files in Mac's Safari browser.
    If the file is not saved, save it first.
    URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
    Version 2018-02-26"
    (interactive)
    (let* (
            ($file-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
                (list (buffer-file-name))))
            ($do-it-p (if (<= (length $file-list) 5)
                        t
                        (y-or-n-p "Open more than 5 files? "))))
        (when $do-it-p
        (cond
        ((string-equal system-type "darwin")
            (mapc
            (lambda ($fpath)
            (when (buffer-modified-p )
                (save-buffer))
            (shell-command
                (format "open -a 'Google Chrome' \"%s\"" $fpath))) $file-list))))))
   #+END_SRC
* My search configs
** Helm config
   #+BEGIN_SRC emacs-lisp

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Helm
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (require 'helm-xref)
     (if (< emacs-major-version 27)
        (setq xref-show-xrefs-function 'helm-xref-show-xrefs)
        (setq xref-show-xrefs-function 'helm-xref-show-xrefs-27))

     (defun z/helm-switch-other-frame()
       (interactive)
       (helm-ff-run-switch-other-frame)
       (delete-other-windows))

     (use-package helm-projectile
       :commands (helm-projectile-configs-load helm-mode helm-projectile-find-file projectile-switch-project)
       :config
       (defun helm-projectile-configs-load ()
         t)
       (run-with-timer 3 nil
                       (lambda ()
                         (message "Loading helm configs...")))
       (require 'helm-projectile)
       (helm-projectile-on)
       (projectile-mode +1)
       (setq projectile-enable-caching t)
       (add-to-list 'exec-path "/usr/local/bin/") ;;Path for running ag ...
       (global-set-key (kbd "<escape>")      'keyboard-escape-quit)
       (load "my-helm-clear-projectile-cache-config")
       ;;Using ESC (ctrl+G) to quit helm command
       (with-eval-after-load "helm-command"
         (define-key helm-M-x-map (kbd "ESC") 'helm-keyboard-quit)
         )

       (add-hook 'helm-after-initialize-hook
                 (lambda()
                   (require 'dash)
                   (require 's)

                   ;(define-key helm-ag-map (kbd "C-s") 'helm-ext-ff-helm-ag-execute-horizontal-split)
                   ;(define-key helm-ag-map (kbd "C-v") 'helm-ext-ff-helm-ag-execute-vertical-split)
                   (define-key helm-projectile-find-file-map (kbd "C-s") 'helm-ext-ff-buffer-execute-horizontal-split)
                   (define-key helm-map (kbd "<s-return>") 'z/helm-switch-other-frame)
                   (define-key helm-map (kbd "C-s") 'helm-ext-ff-buffer-execute-horizontal-split)
                   (define-key helm-map (kbd "C--") 'helm-ext-ff-buffer-execute-horizontal-split)
                   (define-key helm-map (kbd "C-v") 'helm-ext-ff-buffer-execute-vertical-split)
                   (define-key helm-map (kbd "C-u") 'helm-previous-page)
                   (define-key helm-map (kbd "C-d") 'helm-next-page)
                   (define-key helm-map (kbd "C-j") 'helm-next-line)
                   (define-key helm-map (kbd "C-k") 'helm-previous-line)))
       (helm-add-action-to-source "Helm switch other frame and delete other windows" 'z/helm-switch-other-frame helm-source-projectile-projects)
       (helm-add-action-to-source "Split Horizontal" 'helm-ext-ff-buffer-action-horizontal-split helm-source-projectile-files-list)
       (helm-add-action-to-source "Split Horizontal" 'helm-ext-ff-buffer-action-horizontal-split helm-source-projectile-buffers-list)
       (helm-add-action-to-source "Split Horizontal" 'helm-ext-ff-buffer-action-horizontal-split helm-source-projectile-projects)
       ;(helm-add-action-to-source "Split Horizontal" 'helm-ext-ff-helm-ag-action-horizontal-split helm-source-do-ag)
       ;(helm-add-action-to-source "Split Vertical" 'helm-ext-ff-helm-ag-action-vertical-split helm-source-do-ag)
       (helm-add-action-to-source "Split Vertical" 'helm-ext-ff-buffer-action-vertical-split helm-source-projectile-files-list)
       (helm-add-action-to-source "Split Vertical" 'helm-ext-ff-buffer-action-vertical-split helm-source-projectile-buffers-list)
       (helm-add-action-to-source "Split Vertical" 'helm-ext-ff-buffer-action-vertical-split helm-source-projectile-projects))

     (use-package helm-ext
       :defer t
       :config
       (helm-ext-ff-define-split helm-bookmark horizontal bookmark-jump balance)
       (helm-ext-ff-define-split helm-bookmark vertical bookmark-jump balance)
       (helm-ext-ff-define-split helm-ag horizontal (lambda (candidate) (helm-ag--find-file-action candidate 'find-file (helm-ag--search-this-file-p))))

       (helm-add-action-to-source
        "Split Horizontal" 'helm-ext-ff-helm-bookmark-action-horizontal-split helm-source-bookmarks)
       (helm-add-action-to-source
        "Split Vertical" 'helm-ext-ff-helm-bookmark-action-vertical-split helm-source-bookmarks)

       (helm-add-action-to-source
        "Split Horizontal" 'helm-ext-ff-helm-bookmark-action-horizontal-split my--helm-source-bookmark-project)
       (helm-add-action-to-source
        "Split Vertical" 'helm-ext-ff-helm-bookmark-action-vertical-split my--helm-source-bookmark-project))


     (setq helm-mini-default-sources '(helm-source-buffers-list
                                       helm-source-recentf
                                       helm-source-buffer-not-found))
     (setq helm-split-window-in-side-p t ; open helm buffer inside current window, not occupy whole other window
           ;helm-display-function #'helm-display-buffer-in-own-frame ;https://github.com/emacs-helm/helm/wiki/frame
           ;helm-show-completion-display-function #'helm-display-buffer-in-own-frame
           ;helm-display-buffer-width 90
           ;helm-display-buffer-height 30
           helm-actions-inherit-frame-settings t
           helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
           helm-ff-file-name-history-use-recentf t ;
           helm-autoresize-max-height 50
           helm-autoresize-min-height 50
           helm-candidate-number-limit 200
           helm-buffers-fuzzy-matching t
           helm-imenu-fuzzy-match t)
     (helm-autoresize-mode 1)

     (defun w/persp-helm-mini ()
       "As `helm-mini' but restricts visible buffers by perspective."
       (interactive)
       (with-persp-buffer-list ()
                               (helm-mini)))

     (defun w/make-frame ()
       (interactive)
       (select-frame (new-frame)))

     (defun z/magit-status ()
       "Create new frame with magit"
       (interactive)
       (progn
         (select-frame (new-frame))
         (magit-status)
         ))

     (defun w/projectile-switch-project ()
       (interactive)
       (helm-projectile-configs-load)
       (helm-projectile-switch-project)
       ;;(delete-other-windows)
       ;;(neotree-hide)
       )

     (defun w/projectile-switch-project-in-new-frame ()
       (interactive)
       (progn
         (w/make-current-frame)
         (delete-other-windows)
         (helm-projectile-configs-load)
         (helm-projectile-switch-project)))

     (defun w/cleanup-after-switch-project ()
       ;;(delete-other-windows)
       (neotree-hide)
       )
     (add-hook 'projectile-after-switch-project-hook 'w/cleanup-after-switch-project)

     (defun w/projectile-dired ()
       (interactive)
       (helm-projectile-configs-load)
       (projectile-dired)
       )

     (defun w/helm-M-x ()
       (interactive)
       (helm-projectile-configs-load)
       (call-interactively 'helm-M-x)
       )

     (defun w/helm-mini ()
       (interactive)
       (helm-projectile-configs-load)
       (persp-mode)
       (call-interactively 'w/persp-helm-mini)
       )

     (defun w/projectile-file-path ()
       "Retrieve the file path relative to project root.

        Returns:
          - A string containing the file path in case of success.
          - `nil' in case the current buffer does not visit a file."
       (when-let (file-name (buffer-file-name))
         (file-relative-name (file-truename file-name) (projectile-project-root))))

     (defun w/copy-relative-file-path ()
       "Copy and show the file path relative to project root."
       (interactive)
       (if-let (file-path (w/projectile-file-path))
           (progn
             (message "Copied '%s' to clipboard" file-path)
             (kill-new file-path))
         (message "WARNING: Current buffer is not visiting a file!")))

     (defun w/projectile-file-path-with-line ()
       "Retrieve the file path relative to project root, including line number.

        Returns:
          - A string containing the file path in case of success.
          - `nil' in case the current buffer does not visit a file."
       (when-let (file-path (w/projectile-file-path))
         (concat file-path ":" (number-to-string (line-number-at-pos)))))

     (defun w/copy-relative-file-path-with-line ()
       "Copy and show the file path relative to project root."
       (interactive)
       (if-let (file-path (w/projectile-file-path-with-line))
           (progn
             (message "Copied '%s' to clipboard" file-path)
             (kill-new file-path))
         (message "WARNING: Current buffer is not visiting a file!")))

   #+END_SRC

** Neotree config
   #+BEGIN_SRC emacs-lisp
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Neo tree
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;(use-package all-the-icons)
     (use-package neotree
       :commands (neotree-mode)
       :config
       (require 'neotree)
       (message "Loading neotree configs...")
       (with-eval-after-load 'neotree
         (evil-define-key 'normal neotree-mode-map (kbd "TAB") 'neotree-enter)
         (evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
         (evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)
         (evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
         (evil-define-key 'normal neotree-mode-map (kbd "gg") 'evil-goto-first-line)
         (evil-define-key 'normal neotree-mode-map (kbd "C-g") 'neotree-refresh)
         (evil-define-key 'normal neotree-mode-map (kbd "n") 'neotree-next-line)
         (evil-define-key 'normal neotree-mode-map (kbd "p") 'neotree-previous-line)
         (evil-define-key 'normal neotree-mode-map (kbd "A") 'neotree-stretch-toggle)
         (evil-define-key 'normal neotree-mode-map (kbd "T") 'neotree-hidden-file-toggle)
         (evil-define-key 'normal neotree-mode-map (kbd "m") 'neotree-rename-node)
         (evil-define-key 'normal neotree-mode-map (kbd "e") 'neotree-rename-node)
         (evil-define-key 'normal neotree-mode-map (kbd "r") 'neotree-rename-node)
         (evil-define-key 'normal neotree-mode-map (kbd "c") 'neotree-create-node)
         (evil-define-key 'normal neotree-mode-map (kbd "v") 'neotree-enter-vertical-split)
         (evil-define-key 'normal neotree-mode-map (kbd "s") 'neotree-enter-horizontal-split)
         (evil-define-key 'normal neotree-mode-map (kbd "d") 'neotree-delete-node)
         (evil-define-key 'normal neotree-mode-map (kbd "R") 'neotree-delete-node)
         (evil-define-key 'normal neotree-mode-map (kbd "<s-return>") 'neotree-enter)
         )
       )

     (add-hook 'neotree-mode-hook
               (lambda ()
                 (custom-set-faces
                  '(cursor ((t (:background "gold" :foreground "#151718"))))
                  '(mode-line ((t (:background "black" :foreground "#4499FF"))))
                  '(neo-dir-link-face ((t (:foreground "deep sky blue" :slant normal :weight bold :height 90 :family "Inconsolata"))))
                  '(neo-file-link-face ((t (:foreground "White" :weight normal :height 90 :family "Inconsolata")))))
                 ))


    (setq neo-window-fixed-size nil)
    (setq-default neo-show-hidden-files t)

    ;;(setq neo-theme (if (display-graphic-p) 'icons 'arrow))

    (defcustom neo-window-width 30
        "*Specifies the width of the NeoTree window."
        :type 'integer
        :group 'neotree)

    (defun neotree-project-dir-toggle ()
      "Open NeoTree using the project root, using find-file-in-project,
      or the current buffer directory."
      (interactive)
      (let ((project-dir
             (ignore-errors
                ;;; Pick one: projectile or find-file-in-project
                                            ; (projectile-project-root)
               (ffip-project-root)
               ))
            (file-name (buffer-file-name))
            (neo-smart-open t))
        (if (and (fboundp 'neo-global--window-exists-p)
                 (neo-global--window-exists-p))
            (neotree-hide)
          (progn
            (neotree-show)
            (if project-dir
                (neotree-dir project-dir))
            (if file-name
                (neotree-find file-name))))))

   #+END_SRC

** Fzf search config
   #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
       (setenv "PATH" (concat (getenv "PATH") ":~/.fzf/bin"))
       (setq exec-path (append exec-path '(":~/.fzf/bin"))))
     (setq fzf-path (format "%s/packages/fzf.el" w-dotfiles-folder-path))
     (use-package fzf
       :commands fzf
       :load-path fzf-path)

     (general-define-key
      :states '(normal visual insert emacs)
      :prefix w/main-leader-key
      :keymaps 'override
      :non-normal-prefix "M-n"
      "s" '(:ignore t :which-key "search/symbol")
      "sz" '(:ignore t :which-key "fzf search")
      "szf" '(fzf :which-key "files")
      "fzf" '(fzf :which-key "files")
      )
   #+END_SRC
* My edit tools configs
** Flycheck config
   #+BEGIN_SRC emacs-lisp
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; FlyCheck - Syntax error checking
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (setq flycheck-disabled-checkers '(haml)) ;; Disable for haml
     (setq flycheck-highlighting-mode nil)
     (setq flycheck-ruby-rubocop-executable (replace-regexp-in-string  "\n\+$" "" (shell-command-to-string "which rubocop")))
     ;;Issue: flycheck syntax checking makes editing files really slow
     (setq flycheck-check-syntax-automatically '(save idle-change mode-enabled))
     (setq flycheck-idle-change-delay 60) ;; Set delay based on what suits you the best
     (add-hook 'flycheck-mode-hook #'w/flycheck-setup)
     (defun w/flycheck-setup ()
       (use-package flycheck
         :commands flycheck-mode
         :config
         (add-to-list 'display-buffer-alist
                      `(,(rx bos "*Flycheck errors*" eos)
                        (display-buffer-reuse-window
                         display-buffer-in-side-window)
                        (side            . bottom)
                        (reusable-frames . 0)
                        (window-height   . 0.33)))
         )
       )

     (defun flycheck-toggle ()
       (interactive)
       ;; use a property “state”. Value is t or nil
       (if (get 'flycheck-toggle-flag 'state)
           (progn
             (run-with-timer 1 nil
                             (lambda ()
                               (message "Disabled syntax checking")))
             (global-flycheck-mode'-1)
             (put 'flycheck-toggle-flag 'state nil))
         (progn
           (run-with-timer 1 nil
                           (lambda ()
                             (message "Enabled syntax checking")))
           (global-flycheck-mode)
           (put 'flycheck-toggle-flag 'state t))
         ))

     (defun force-my-flycheck-enable-first-time ()
       (if (and (not(get 'flycheck-toggle-flag 'state)) (not(get 'flycheck-toggle-first-time-flag 'state)))
           (progn
             (global-flycheck-mode)
             (use-package evil-evilified-state
               :load-path evil-evilified-state-path)

             (evilified-state-evilify-map flycheck-error-list-mode-map
               :mode flycheck-error-list-mode
               :bindings
               "RET" 'flycheck-error-list-goto-error
               "j" 'flycheck-error-list-next-error
               "k" 'flycheck-error-list-previous-error)
             (put 'flycheck-toggle-flag 'state t)
             (put 'flycheck-toggle-first-time-flag 'state t)))
       )

     (defun force-run-flycheck ()
       (interactive)
       (progn
         (force-my-flycheck-enable-first-time)
         (flycheck-buffer))
       )

     ;Only init flycheck when saving
     (add-hook 'after-save-hook 'force-my-flycheck-enable-first-time)
     (add-hook 'ruby-mode-hook
               (lambda ()
                 (setq flycheck-disabled-checkers '(ruby-reek))
                 ))
   #+END_SRC

** Auto complete config
   - Basic bindings(evil edit mode): C-g to abort, C-f to show the menu, C-p C-n to select previous or next, C-l to complete
   #+BEGIN_SRC emacs-lisp

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Auto Complete
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (use-package company
       :ensure t
       :defer t
       :init (global-company-mode)
       :config
       (define-key company-active-map (kbd "C-n") 'company-select-next)
       (define-key company-active-map (kbd "C-j") 'company-select-next)
       (define-key company-active-map (kbd "C-p") 'company-select-previous)
       (define-key company-active-map (kbd "C-k") 'company-select-previous)
       (define-key company-active-map (kbd "C-l") 'company-complete)
       (define-key company-active-map (kbd "C-f") 'company-complete)
       (setq company-backends
             '(company-bbdb company-nxml company-css company-eclim
                            company-semantic company-xcode company-cmake
                            company-capf
                            (company-dabbrev-code company-gtags company-etags
                                                  company-keywords)
                            company-oddmuse company-files company-dabbrev))
       (setq company-idle-delay 0.1
             company-minimum-prefix-length 2
             company-selection-wrap-around t
             company-show-numbers t
             company-tooltip-align-annotations t
             company-dabbrev-downcase nil
             company-dabbrev-other-buffers t
             company-dabbrev-code-other-buffers 'all
             company-dabbrev-code-everywhere t
             company-dabbrev-code-ingore-case t
             company-dabbrev-ignore-case t)
       ;;Trigger auto complete menu
       (with-eval-after-load "evil"
         (define-key evil-insert-state-map (kbd "C-f") 'company-dabbrev-code)
         )
       )

     ; https://emacs.stackexchange.com/questions/14802/never-keep-current-list-of-tags-tables-also
     (setq tags-add-tables nil)
   #+END_SRC

** COMMENT Auto complete fuzzy config using company-flx
   - For research. it's very slow
   - Dependent packages: company, robe(for ruby)
   #+BEGIN_SRC emacs-lisp
     (use-package flx
       :ensure t
       :defer t
       )

     (use-package flx-ido
       :ensure t
       :defer t
       )

     (use-package company-flx
       :ensure t
       :commands (company-flx-mode)
       :config
       (setq company-flx-limit 5)
       :init
       (add-hook 'global-company-mode-hook 'company-flx-mode))


     (with-eval-after-load 'company
       (add-hook 'company-mode-hook (lambda ()
                                      (add-to-list 'company-backends 'company-capf)))
       (company-flx-mode +1))
   #+END_SRC
** Multi cursors config
   - Use "g r f" to make a cursor at selected text (visual mode)
   - Use "C-n" to go to the next match
   - Use "g r n" to to skip the current match
   - Use "C-p" to go to the previous match
   - Use "g r u" to undo all cursors
   #+BEGIN_SRC emacs-lisp
     (defun w/evil-mc-column-number-at-pos (pos)
       "Analog to line-number-at-pos."
       (save-excursion (goto-char pos) (current-column)))

     (defun w/evil-mc-pos-at-line-column (line column)
       (save-excursion (goto-line line) (move-to-column column) (point)))

     (defun w/evil-mc-make-cursor-at-visual-region ()
       (interactive)
       (let ((row-count (- (line-number-at-pos (region-end)) (line-number-at-pos (region-beginning))))
             (inc-var 1)
             (first-line (line-number-at-pos (region-beginning)))
             (current-line (line-number-at-pos (point)))
             (current-column (w/evil-mc-column-number-at-pos (point))))
         (normal-mode)
         (global-evil-mc-mode +1)
         (evil-mc-run-cursors-before)
         (while (< inc-var (+ row-count 1))
           (if (eq first-line current-line)
               (evil-mc-make-cursor-at-pos (w/evil-mc-pos-at-line-column (+ (line-number-at-pos (point)) inc-var)
                                                                 current-column)
                                           )
             (evil-mc-make-cursor-at-pos (w/evil-mc-pos-at-line-column (- (line-number-at-pos (point)) inc-var)
                                                               (- current-column 1))
                                         )
             )
           (setq inc-var (+ inc-var 1))
           )
         (if (not(eq first-line current-line))
             (move-to-column (- current-column 1))
           )
         )
       )

     (general-define-key
      :states '(visual)
      "g r f" 'evil-mc-make-and-goto-first-cursor
      "g r v" '((lambda () (interactive) (w/evil-mc-make-cursor-at-visual-region)) :which-key "make cursors vertically")
      )

     (use-package evil-mc
       :ensure t
       :commands (evil-mc-make-and-goto-first-cursor evil-mc-make-cursor-here evil-mc-pause-cursors evil-mc-undo-all-cursors)
       :config
       (global-evil-mc-mode +1))
   #+END_SRC
* My git tools config
** Magit config
   #+BEGIN_SRC emacs-lisp
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Magit - GIT tools
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (use-package magit
       :commands (magit-blame-mode magit-blame)
       :config
       (evil-make-overriding-map magit-blame-mode-map 'normal)
       (add-hook 'magit-blame-mode-hook 'evil-normalize-keymaps)
       (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

       (require 'evil-magit)
                                             ;Full screen git status
       (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
       (define-key magit-mode-map "\C-j" 'magit-section-forward)
       (define-key magit-mode-map "\C-k" 'magit-section-backward)
       (define-key magit-mode-map "\M-j" 'magit-section-forward-sibling)
       (define-key magit-mode-map "\M-k" 'magit-section-backward-sibling)
       )

     (use-package git-timemachine
       :commands (git-timemachine)
       :config

       (defun git-timemachine-blame ()
         "Call magit-blame on current revision."
         (interactive)
         (if (fboundp 'magit-blame)
             (let ((magit-buffer-revision (car git-timemachine-revision)))
               (magit-blame))
           (message "You need to install magit for blame capabilities")))

       (defun git-timemachine-find-revision-by-id (revision-id)
         (require 'cl)
         (message revision-id)
         (cl-loop for v in (git-timemachine--revisions)
                  until (cl-search revision-id (nth 0 v))
                  finally return v
                  )
         )
       (defun git-timemachine-go-to-revision-id (revision-id)
         (interactive "sEnter revision id: ")
         (git-timemachine-show-revision (git-timemachine-find-revision-by-id revision-id))
         )
       (evil-define-key 'normal git-timemachine-mode-map (kbd "G") 'git-timemachine-go-to-revision-id)
       )

     (use-package git-gutter
       :commands (global-git-gutter-mode git-gutter-mode)
       :config
       (progn
         (set-face-background 'git-gutter:deleted "#990A1B")
         (set-face-foreground 'git-gutter:modified "#00736F")
         (set-face-foreground 'git-gutter:added "#546E00"))
       )
                                             ;Init git gutter when saving
     (global-git-gutter-mode +1)

     (eval-after-load 'git-timemachine
       '(progn
          (evil-make-overriding-map git-timemachine-mode-map 'normal)
          ;; force update evil keymaps after git-timemachine-mode loaded
          (add-hook 'git-timemachine-mode-hook #'evil-normalize-keymaps)))

     (defun w/git-last-commit-message ()
       (interactive)
       (let ((git-message (shell-command-to-string "git log -1 --pretty=%B 2>/dev/null")))
         (kill-new git-message)
         )
       )
   #+END_SRC

** Annotate(Git blame)
   - Mapping evil bindings for git blame
   - Basic bindings: Toggle detail ~A~, Copy revision ~W~
   #+BEGIN_SRC emacs-lisp
     (evil-set-initial-state 'vc-annotate-mode 'normal)
     (general-define-key
      :states '(normal)
      :keymaps 'vc-annotate-mode-map
      "q" 'quit-window
      "a" 'vc-annotate-revision-previous-to-line
      "d" 'vc-annotate-show-diff-revision-at-line
      "=" 'vc-annotate-show-diff-revision-at-line
      "D" 'vc-annotate-show-changeset-diff-revision-at-line
      "F" 'vc-annotate-find-revision-at-line
      "J" 'vc-annotate-revision-at-line
      "L" 'vc-annotate-show-log-revision-at-line
      "gj" 'vc-annotate-next-revision
      "gk" 'vc-annotate-prev-revision
      "]" 'vc-annotate-next-revision
      "[" 'vc-annotate-prev-revision
      (kbd "C-j") 'vc-annotate-next-revision
      (kbd "C-k") 'vc-annotate-prev-revision
      "W" 'vc-annotate-working-revision
      "A" 'vc-annotate-toggle-annotation-visibility
      (kbd "RET") 'vc-annotate-goto-line)

     (eval-after-load "vc-annotate"
       '(progn
          (setq
           vc-annotate-background nil
           vc-annotate-background-mode nil
           vc-annotate-very-old-color nil
           vc-annotate-color-map '((20 . (face-attribute 'default :foreground))
                                   (40 . (face-attribute 'default :foreground))
                                   (60 . (face-attribute 'default :foreground))
                                   (80 . (face-attribute 'default :foreground))
                                   (100 . (face-attribute 'default :foreground))
                                   (120 . (face-attribute 'default :foreground))
                                   (140 . (face-attribute 'default :foreground))
                                   (160 . (face-attribute 'default :foreground))
                                   (180 . (face-attribute 'default :foreground))
                                   (200 . (face-attribute 'default :foreground))
                                   (220 . (face-attribute 'default :foreground))
                                   (240 . (face-attribute 'default :foreground))
                                   (260 . (face-attribute 'default :foreground))
                                   (280 . (face-attribute 'default :foreground))
                                   (300 . (face-attribute 'default :foreground))
                                   (320 . (face-attribute 'default :foreground))
                                   (340 . (face-attribute 'default :foreground))
                                   (360 . (face-attribute 'default :foreground))))
          ))

     ;; Show only the author toggle
     (eval-after-load "vc-annotate"
       '(defun vc-annotate-get-time-set-line-props ()
          (let ((bol (point))
                (date (vc-call-backend vc-annotate-backend 'annotate-time))
                (inhibit-read-only t))
            (assert (>= (point) bol))
            (put-text-property bol (point) 'invisible 'vc-annotate-annotation)
            (when (string-equal "Git" vc-annotate-backend)
              (save-excursion
                (goto-char bol)
                (search-forward "(")
                (let ((p1 (point)))
                  (re-search-forward " [0-9]")
                  (remove-text-properties p1 (1- (point)) '(invisible nil))
                  )))
            date)))
   #+END_SRC
** Forge

   #+BEGIN_SRC emacs-lisp
     (use-package forge
      :after magit)
   #+END_SRC
* My ui configs
** space line config
   #+BEGIN_SRC emacs-lisp
     (autoload 'tags-tree "tags-tree" "TAGS tree" t)
     (autoload 'imenu-tree "imenu-tree" "Imenu tree" t)
     (setq imenu-max-item-length +500)
     (setq anzu-cons-mode-line-p nil)
     (setq imenu-auto-rescan t)
     (yaml-imenu-enable)
     (global-anzu-mode +1)
     (which-function-mode +1)
     (defun w/spaceline-setup ()
       (use-package spaceline-config
         :ensure spaceline
         :config
         (require 'spaceline-config)
         (spaceline-spacemacs-theme)
         )
       (spaceline-compile
         ; left side
         '(((persp-name
             workspace-number
             window-number)
            :fallback evil-state
            :face highlight-face
            :priority 100)
           (anzu :priority 95)
           auto-compile
           ((buffer-modified buffer-size buffer-id remote-host)
            :priority 98)
           (major-mode :priority 79)
           (process :when active)
           ((flycheck-error flycheck-warning flycheck-info)
            :when active
            :priority 89)
           (minor-modes :when active
                        :priority 9)
           (mu4e-alert-segment :when active)
           (erc-track :when active)
           (version-control :when active
                            :priority 78)
           (org-pomodoro :when active)
           (org-clock :when active)
           nyan-cat)
         ; right side
         '(which-function
           (python-pyvenv :fallback python-pyenv)
           (purpose :priority 94)
           (battery :when active)
           (selection-info :priority 95)
           input-method
           ((buffer-encoding-abbrev
             point-position
             line-column)
            :separator " | "
            :priority 96)
           (global :when active)
           (buffer-position :priority 99)
           (hud :priority 99)))
       (spaceline-toggle-minor-modes-off)
       )

     (defun z/which-function ()
       "Return current function name based on point.
         Uses `which-func-functions', `imenu--index-alist'
         or `add-log-current-defun'.
         If no function name is found, return nil."
       (interactive)
       (let ((name
              ;; Try the `which-func-functions' functions first.
              (run-hook-with-args-until-success 'which-func-functions)))

         ;; If Imenu is loaded, try to make an index alist with it.
         (when (and (null name)
                    (boundp 'imenu--index-alist) (null imenu--index-alist)
                    (null which-function-imenu-failed))
           (ignore-errors (imenu--make-index-alist t))
           (unless imenu--index-alist
             (set (make-local-variable 'which-function-imenu-failed) t)))
         ;; If we have an index alist, use it.
         (when (and (null name)
                    (boundp 'imenu--index-alist) imenu--index-alist)
           (let ((alist imenu--index-alist)
                 (minoffset (point-max))
                 offset pair mark imstack namestack)
             ;; Elements of alist are either ("name" . marker), or
             ;; ("submenu" ("name" . marker) ... ). The list can be
             ;; arbitrarily nested.
             (while (or alist imstack)
               (if (null alist)
                   (setq alist     (car imstack)
                         namestack (cdr namestack)
                         imstack   (cdr imstack))

                 (setq pair (car-safe alist)
                       alist (cdr-safe alist))

                 (cond
                  ((atom pair))              ; Skip anything not a cons.

                  ((imenu--subalist-p pair)
                   (setq imstack   (cons alist imstack)
                         namestack (cons (car pair) namestack)
                         alist     (cdr pair)))

                  ((or (number-or-marker-p (setq mark (cdr pair)))
                       (and (overlayp mark)
                            (setq mark (overlay-start mark))))
                   (when (and (>= (setq offset (- (point) mark)) 0)
                              (< offset minoffset)) ; Find the closest item.
                     (setq minoffset offset
                           name (if (null which-func-imenu-joiner-function)
                                    (car pair)
                                  (funcall
                                   which-func-imenu-joiner-function
                                   (reverse (cons (car pair) namestack))))))))))))

         ;; Try using add-log support.
         (when (null name)
           (setq name (add-log-current-defun)))
         ;; Filter the name if requested.
         (when name
           (if which-func-cleanup-function
               (funcall which-func-cleanup-function name)
             name))
         (message "Copied '%s' to clipboard" name)
         (kill-new name)))

       (add-hook 'after-init-hook 'w/spaceline-setup)
   #+END_SRC

** indent guide config
   #+BEGIN_SRC emacs-lisp
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Indent guide
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (use-package indent-guide
      :commands (indent-guide-global-mode)
      :config
      (run-with-timer 3 nil
                      (lambda ()
                        (message "Loading indent-guide configs...")))
      (require 'indent-guide)
      )

    (defun indent-guide-toggle ()
      (interactive)
      ;; use a property “state”. Value is t or nil
      (if (get 'indent-guide-toggle-flag 'state)
          (progn
            (run-with-timer 1 nil
                            (lambda ()
                              (message "Disabled indent guide")))
            (indent-guide-global-mode -1)
            (put 'indent-guide-toggle-flag 'state nil))
        (progn
          (run-with-timer 1 nil
                          (lambda ()
                            (message "Enabled indent guide")))
          (indent-guide-global-mode)
          (put 'indent-guide-toggle-flag 'state t))
        ))
    #+END_SRC

** highlight-indent-guides config
    #+BEGIN_SRC emacs-lisp
    (setq highlight-indent-guides-method 'character)
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    #+END_SRC

* Other tools configs
** language server protocol (lsp-mode)
   - LSP is what makes Emacs full featured IDE (code navigation & completion)
   - Dependencies: company, company-lsp
   - To run server manually: call ~(lsp)~
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :ensure t
       :init
       (add-hook 'prog-major-mode #'lsp-prog-major-mode-enable)
       :config
       (setq lsp-prefer-flymake nil
             lsp-auto-guess-root t
             lsp-keep-workspace-alive nil)
       (ht-set! lsp--default-notification-handlers "client/registerCapability" 'ignore)

       (setq lsp-response-timeout 5)
       (setq lsp-print-io t)
       (setq lsp-eldoc-render-all t))

     (use-package company-lsp
       :ensure t
       :init
       (push 'company-lsp company-backends)
       :config
       (setq company-lsp-async t)
       )

     (use-package lsp-ui
       :ensure t
       :init
       (add-hook 'lsp-mode-hook 'lsp-ui-mode)
       :config
       (setq lsp-ui-sideline-show-hover nil)
       (setq lsp-ui-doc-enable nil)
       )

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Fix slow LSP flycheck
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (defvar lsp-ui-flycheck--stale-diagnostics nil)

     (defun lsp-ui-flycheck-enable (_)
       "Enable flycheck integration for the current buffer."
       (setq-local flycheck-check-syntax-automatically nil)
       (setq-local flycheck-checker 'lsp-ui)
       (lsp-ui-flycheck-add-mode major-mode)
       (add-to-list 'flycheck-checkers 'lsp-ui)
       (run-with-idle-timer 0.2 t
                            (lambda () (when (and lsp-ui-flycheck--stale-diagnostics flycheck-mode)
                                         (flycheck-buffer)
                                         (setq lsp-ui-flycheck--stale-diagnostics nil))))
       (add-hook 'lsp-after-diagnostics-hook (lambda ()
                                               (setq lsp-ui-flycheck--stale-diagnostics t)
                                               )))
   #+END_SRC
** workspace(PERSP MODE) config
   save/recover sessions
   #+BEGIN_SRC emacs-lisp
     (defun w/ivy-persp-switch-project (arg)
       (interactive "P")
       (persp-mode)
       (helm-projectile-configs-load)
       (ivy-mode)
       (define-key ivy-minibuffer-map (kbd "C-j") 'ivy-next-line)
       (define-key ivy-minibuffer-map (kbd "C-k") 'ivy-previous-line)
       (ivy-read "Switch to Project Perspective: "
                 (if (projectile-project-p)
                     (cons (abbreviate-file-name (projectile-project-root))
                           (projectile-relevant-known-projects))
                   projectile-known-projects)
                 :action (lambda (project)
                           (let* ((persp-reset-windows-on-nil-window-conf t)
                                  (exists (persp-with-name-exists-p project)))
                             (persp-switch project)
                             (unless exists
                               (progn
                                 (let ((projectile-completion-system 'ivy))
                                   (projectile-switch-project-by-name project))))))))

     ;; perspectives for emacs
     (defun w/persp-load-state-from-file ()
       (interactive)
       (persp-mode 1)
       (call-interactively 'persp-load-state-from-file)
       )

     (defun w/persp-save-state-to-file ()
       (interactive)
       (persp-mode 1)
       (call-interactively 'persp-save-state-to-file)
       )

     (use-package persp-mode
       :commands (persp-mode)
       :init
       (setq wg-morph-on nil ;; switch off animation
             persp-add-buffer-on-after-change-major-mode t
             persp-auto-resume-time -1
             persp-autokill-buffer-on-remove 'kill-weak
             persp-save-dir (expand-file-name "~/.emacs.d/.cache/layouts/"))
       )
   #+END_SRC
** org mode config
   #+BEGIN_SRC emacs-lisp
     (defun loading-org-mode-dependencies ()
       (interactive)
       (load "my-org-mode-dependencies-config")
       )
     (add-hook 'org-mode-hook 'loading-org-mode-dependencies)

     ;; https://orgmode.org/manual/Cooperation.html
     ;; (setq org-imenu-depth +5)
     ;; (add-hook 'org-mode-hook
     ;;      (lambda () (imenu-add-to-menubar "Imenu")))
   #+END_SRC
** ruby mode config
*** rbenv
   #+BEGIN_SRC emacs-lisp
     (use-package rbenv
       :commands (global-rbenv-mode)
       :init (setq rbenv-show-active-ruby-in-modeline nil)
       :config (progn
                 (global-rbenv-mode)
                 (add-hook 'enh-ruby-mode-hook 'rbenv-use-corresponding)
                 (add-hook 'enh-ruby-mode-hook 'rbenv-use-corresponding)
                 (add-hook 'ruby-mode-hook 'rbenv-use-corresponding)
                 ))

     (add-hook 'ruby-mode-hook (lambda () (global-rbenv-mode) (rbenv-use-global)))
   #+END_SRC
*** inf-ruby and other configs
   #+BEGIN_SRC emacs-lisp
     (use-package inf-ruby
       :commands (inf-ruby-minor-mode)
       :config
       (eval-after-load 'inf-ruby
         '(rbenv-use-corresponding))
       (eval-after-load 'inf-ruby
         '(define-key inf-ruby-mode-map
            (kbd "C-k") 'comint-previous-input))
       (eval-after-load 'inf-ruby
         '(define-key inf-ruby-mode-map
            (kbd "C-j") 'comint-next-input))
       (setq inf-ruby-console-environment "development")
       )
     (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

     (use-package ruby-test-mode
       :commands (ruby-test-mode)
       :config
       (require 'ruby-test-mode)
       )

     (add-hook 'ruby-mode-hook 'ruby-test-mode)
   #+END_SRC
*** rope (code navigation & completion)
    - Robe mode is what makes Emacs full featured IDE
    - Robe mode may confict with solargraph
    - Dependent packages: company.
    - Enable it by using ~M-x robe-start~ (~SPC SPC robe-start~)
    #+BEGIN_SRC emacs-lisp
      (use-package robe
        :defer t
        :ensure t
        :after ruby-mode
        :init
        (progn
          (add-hook 'ruby-mode-hook 'robe-mode)
          (with-eval-after-load 'company
            (add-to-list 'company-backends 'company-robe))))
    #+END_SRC

*** ruby language server protocol (solargraph)
    - Robe mode may confict with solargraph
    - Dependencies: lsp-mode
    - To make this config work, you will need to:
    1. *Run* ~gem install solargraph~ in your ruby repo
    2. *Run* ~gem install yard~ and ~yard config --gem-install-yri~ and ~yard gems~ in your ruby repo to access source code of gems
    #+BEGIN_SRC emacs-lisp
      (add-hook 'ruby-mode-hook (lambda ()
                                  (add-to-list 'company-lsp-filter-candidates '(w-ruby-ls . nil))
                                  (setq ruby-language-server-path (format "%s/ruby/bin/solargraph" w-dotfiles-folder-path))
                                  (defun lsp-clients-ruby--make-init-options ()
                                    "Init options for Ruby. (syntax checking enabled)"
                                    '(:diagnostics t))

                                  (lsp-register-client
                                   (make-lsp-client :new-connection (lsp-stdio-connection
                                                                     (list ruby-language-server-path "stdio")
                                                                     )
                                                    :major-modes '(ruby-mode)
                                                    :initialization-options #'lsp-clients-ruby--make-init-options
                                                    :priority -1
                                                    :server-id 'w-ruby-ls))
                                  (if (get-buffer-process "*w-ruby-ls*")
                                      (lsp)
                                    )
                                  ))

      ;;Mapping for ruby mode
      (general-define-key
       :states '(normal visual insert emacs)
       :prefix w/secondary-leader-key
       :non-normal-prefix "M-n"
       :keymaps 'ruby-mode-map
       "s" '(:ignore t :which-key "start")
       "sl" '(lsp :which-key "start language server")
       "sx" '(lsp-ui-flycheck-list--quit :which-key "stop language server")
       "sf" '(lsp-find-definition :which-key "find definition")
       "ss" '(helm-imenu :which-key "display document structure")
       )

    #+END_SRC
*** ruby debugger (dap-mode)
    - To make this config work, you will need to:
    1. *Run* ~gem install ruby-debug-ide -v 0.6.1~ AND ~gem install debase~ in your ruby repo
    2. *Run* ~brew install node~ to install node
    #+BEGIN_SRC emacs-lisp
      (setq dap-ruby-debug-program `("node" ,(expand-file-name (format "%s/ruby/debugger/rebornix.Ruby-0.22.3/extension/out/debugger/main.js" w-dotfiles-folder-path))))
      (use-package hydra
        :ensure t
        :defer t
        )

     (defun hydra-git-timemachine-on ()
       (interactive)
       (git-timemachine)
       (hydra-git-timemachine/body))

      (defhydra hydra-git-timemachine
       (:color pink :hint nil :exit t)
       ("n" git-timemachine-show-next-revision "Next Revision" :column "Go to")
       ("p" git-timemachine-show-previous-revision "Next Revision")
       ("c" git-timemachine-show-current-revision "Current Revision")
       ("g" git-timemachine-show-nth-revision "Nth Revision")
       ("t" git-timemachine-show-revision-fuzzy "Search")
       ("W" git-timemachine-kill-revision "Copy full revision" :column "Actions")
       ("w" git-timemachine-kill-abbreviated-revision "Copy abbreviated revision" :column "Actions")
       ("C" git-timemachine-show-commit "Show commit")
       ("b" git-timemachine-blame "Blame")
       ("G" git-timemachine-go-to-revision-id "Revision Id")
       ("q" git-timemachine-quit "cancel" :color blue :column nil))

      (defhydra hydra-smerge (:hint nil)
        ("n" smerge-next "next hunk" :column "Movement")
        ("p" smerge-prev "prev hunk")
        ("N" smerge-prev "prev hunk")
        ("k" evil-previous-line "move up")
        ("j" evil-next-line "move down")
        ("C-u" evil-scroll-up "scroll up")
        ("C-d" evil-scroll-down "scroll down")
        ("b" smerge-keep-base "keep base" :column "Merge action")
        ("m" smerge-keep-mine "keep mine")
        ("a" smerge-keep-all "keep all")
        ("o" smerge-keep-other "keep other")
        ("c" smerge-keep-current "keep current")
        ("C" smerge-combine-with-next "combine with next")
        ("u" undo-tree-undo "undo" :column "Other")
        ("r" smerge-refine "refine")
        ("q" nil "quit"))


      (use-package dap-mode
        :ensure t
        :after hydra
        :defer t
        )

      (add-hook 'ruby-mode-hook (lambda ()
                                  (dap-mode 1)
                                  (dap-ui-mode 1)
                                  (dap-register-debug-provider "Ruby" 'w/dap-ruby--populate-start-file-args)
                                  ))

      (defun w/rbenv-rspec-path ()
        (setq w/ruby-rspec-path (replace-regexp-in-string  "\n\+$" "" (shell-command-to-string "bundle exec ruby -e \"puts(Gem.bin_path('rspec-core', 'rspec', '>= 0.a'))\" 2>/dev/null")))
        (expand-file-name
         (format "%s" w/ruby-rspec-path)))

      (defun w/dap-ruby--populate-start-file-args (conf)
        "Populate CONF with the required arguments."
        (-> conf
            (dap--put-if-absent :dap-server-path dap-ruby-debug-program)
            (dap--put-if-absent :type "Ruby")
            (dap--put-if-absent :cwd (projectile-project-root))
            (dap--put-if-absent :program (buffer-file-name))
            (dap--put-if-absent :args `(,buffer-file-name))
            (dap--put-if-absent :name "Ruby Debug")))


      (setq w/ruby-rdebug-ide-path (format "%s/ruby/debugger/ruby-debug-ide-0.6.1/bin/rdebug-ide" w-dotfiles-folder-path))
      (defun w/dap-ruby-run-test-at-point ()
        "Run test.
                  If there is no method under cursor it will fallback to test class."
        (interactive)
        (let ((debug-args (list :type "Ruby"

                                :debuggerPort 1235
                                :cwd (projectile-project-root)
                                :request "launch"
                                :program (w/rbenv-rspec-path)
                                :useBundler nil
                                :rdebugIdePath w/ruby-rdebug-ide-path
                                :args `(,(w/file-path-with-line))
                                :name "Rspec File At Point")))
          (dap-start-debugging (-some-> (plist-get debug-args :type)
                                        (gethash dap--debug-providers)
                                        (funcall debug-args)))))

      (defun w/dap-ruby-run-test ()
        "Run test.
                  If there is no method under cursor it will fallback to test class."
        (interactive)
        (let ((debug-args (list :type "Ruby"
                                :debuggerPort 1235
                                :request "launch"
                                :program (w/rbenv-rspec-path)
                                :useBundler nil
                                :rdebugIdePath w/ruby-rdebug-ide-path
                                :args `(,buffer-file-name)
                                :name "Rspec File")))
          (dap-start-debugging (-some-> (plist-get debug-args :type)
                                        (gethash dap--debug-providers)
                                        (funcall debug-args)))))
      (defun w/dap-ruby-run-rails-s ()
        "Run test.
                  If there is no method under cursor it will fallback to test class."
        (interactive)
        (let ((debug-args (list :type "Ruby"
                                :cwd (projectile-project-root)
                                :request "launch"
                                :program "bin/rails"
                                :environment-variables '(("DISABLE_SPRING" . "true"))
                                :rdebugIdePath w/ruby-rdebug-ide-path
                                :args '("s")
                                :name "Rails server")))
          (dap-start-debugging (-some-> (plist-get debug-args :type)
                                        (gethash dap--debug-providers)
                                        (funcall debug-args)))))
      ;;Mapping for ruby mode
      (general-define-key
       :states '(normal visual insert emacs)
       :prefix w/secondary-leader-key
       :non-normal-prefix "M-n"
       :keymaps 'ruby-mode-map
       "sS" '(:ignore t :which-key "server")
       "sSr" 'w/dap-ruby-run-rails-s
       "td" '(:ignore t :which-key "test with debugger")
       "tdp" '(dap-breakpoint-toggle :which-key "Set breakpoint")
       "tdh" '(dap-hydra :which-key "Debug guide")
       "tdt" '(w/dap-ruby-run-test-at-point :which-key "Run test at point")
       "tdb" '(w/dap-ruby-run-test :which-key "Run all tests")
       "d" '(:ignore t :which-key "debugger tools")
       "dn" 'dap-next
       "di" 'dap-step-in
       "do" 'dap-step-out
       "dc" 'dap-continue
       "dr" 'dap-restart-frame
       "ds" '(:ignore t :which-key "Switch")
       "dss" 'dap-switch-session
       "dst" 'dap-switch-thread
       "dsf" 'dap-switch-stack-frame
       "dsl" 'dap-ui-locals
       "dsb" 'dap-ui-breakpoints
       "dsS" 'dap-ui-sessions
       "db" '(:ignore t :which-key "Breakpoints")
       "dbt" 'dap-breakpoint-toggle
       "dba" 'dap-breakpoint-add
       "dbd" 'dap-breakpoint-delete
       "dbc" 'dap-breakpoint-condition
       "dbh" 'dap-breakpoint-hit-condition
       "dbl" 'dap-breakpoint-log-message
       "de" '(:ignore t :which-key "Eval")
       "dee" 'dap-eval
       "der" 'dap-eval-region
       "des" 'dap-eval-thing-at-point
       "dei" '(:ignore t :which-key "Inspect")
       "deii" 'dap-ui-inspect
       "deir" 'dap-ui-inspect-region
       "deis" 'dap-ui-inspect-thing-at-point
       "Q" 'dap-disconnect
       )
    #+END_SRC
*** hs-minor-mode-ruby
    #+BEGIN_SRC emacs-lisp
    (add-hook 'ruby-mode-hook
      (lambda () (hs-minor-mode)))

    (eval-after-load "hideshow"
      '(add-to-list 'hs-special-modes-alist
        `(ruby-mode
          ,(rx (or "def" "class" "module" "do" "{" "[")) ; Block start
          ,(rx (or "}" "]" "end"))                       ; Block end
          ,(rx (or "#" "=begin"))                        ; Comment start
          ruby-forward-sexp nil)))

    (global-set-key (kbd "C-c h") 'hs-hide-block)
    (global-set-key (kbd "C-c s") 'hs-show-block)
    (defun z/eval-region(beg end)
      (interactive "r")
      (eval-region beg end)
      (message "Eval region !!!"))
    (defun z/eval-last-sexp(eval-last-sexp-arg-internal)
      (interactive "P")
      (message "Eval last sexp !!!")
      (eval-last-sexp eval-last-sexp-arg-internal))
    #+END_SRC

    #+RESULTS:
    : hs-show-block

** go-mode config

#+BEGIN_SRC emacs-lisp

#+END_SRC

** js config
   #+BEGIN_SRC emacs-lisp
      (require 'web-mode)
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
      (setq web-mode-engines-alist
            '(("php"    . "\\.phtml\\'")
              ("blade"  . "\\.blade\\.")
              ("go"     . "\\.tpl\\'")))

     (use-package js2-mode
       :ensure t
       :defer t
       :mode (("\\.m?js\\'"  . js2-mode))
       :init
       (setq-default
        js2-basic-offset 2
        js-indent-level 2)
       (setq js2-mode-show-parse-errors nil)
       (setq js2-mode-show-strict-warnings nil)
       :config
       (add-hook 'js2-mode #'turn-on-evil-matchit-mode)
       (add-hook 'js2-init-hook
                 '(lambda ()
                    (setq next-error-function 'flycheck-next-error)
                    )))

     (use-package add-node-modules-path
       :ensure t
       :after js2-mode
       :config
       (add-hook 'js2-mode-hook #'add-node-modules-path))

     (use-package prettier-js
       :ensure t
       :after js2-mode
       :config
       (add-hook 'js2-mode-hook #'prettier-js-mode)
       (add-hook 'web-mode-hook #'prettier-js-mode))

     (use-package import-js
       :ensure t
       :after js2-mode)

     (use-package smartparens
       :ensure t
       :after js2-mode)

   #+END_SRC

** Reason mode config
*** reasonml lang server config
    - Reason mode for reason react development 🐫
    - Dependencies: lsp-mode
    - To make this config work, you must:
    1. *Run* ~ln -sf ~/w_emacs_dotfiles/reasonml/bin/reason-language-server /usr/local/bin~ and update reason-language-server-path to ~/usr/local/bin/reason-language-server-path~ if you don't use the whole dotfiles

* Experiments
   #+BEGIN_SRC emacs-lisp
     (pdf-tools-install)
     (require 'go-imenu) ;; Don't need to require, if you install by package.el
     (add-hook 'go-mode-hook 'go-imenu-setup)
     ;; https://github.com/emacs-evil/evil-collection
     (setq evil-collection-mode-list nil)
     (with-eval-after-load 'pdf-tools (require 'evil-collection-pdf) (evil-collection-pdf-setup)) ; why this works ? but below won't ? ; (evil-collection-init 'pdf) ;why this not works ?
     (evil-collection-init 'help)
     (evil-collection-init 'occur)
     (evil-collection-init)

     (defun eab/push-button-on-file-same-window ()
       "https://emacs.stackexchange.com/questions/24693/make-opening-clickable-filenames-from-help-mode-in-same-window"
       (interactive)
       (let ((cwc (current-window-configuration))
             (hb (current-buffer))
             (file? (button-get (button-at (point)) 'help-args)))
         (funcall
          `(lambda ()
             (defun eab/push-button-on-file-same-window-internal ()
               (if (> (length ',file?) 1)
                   (let ((cb (current-buffer)))
                     (set-window-configuration ,cwc)
                     (switch-to-buffer cb)
                     (kill-buffer ,hb)))))))
       (call-interactively 'push-button)
       (run-with-timer 0.01 nil 'eab/push-button-on-file-same-window-internal))

     (evil-collection-define-key 'normal 'help-mode-map
       ;; The following bindings don't do what they are supposed to. "go" should open
       ;; in the same window and "gO" should open in a different one.
       "go" 'eab/push-button-on-file-same-window
       "gO" 'push-button
       )

     (evil-collection-define-key 'normal 'pdf-outline-buffer-mode-map
       (kbd "TAB") 'pdf-outline-toggle-subtree
       (kbd "C-j") 'outline-forward-same-level
       (kbd "C-k") 'outline-backward-same-level
       (kbd "RET") 'pdf-outline-display-link
       "o"         'pdf-outline-follow-link
       "O"         'pdf-outline-follow-link-and-quit
       "A"         'show-all
       "q"         '(lambda () (interactive) (if (y-or-n-p "Quit outline window ?") (quit-window)))
       )

     (defun toggle-transparency ()
       (interactive)
       (let ((alpha (frame-parameter nil 'alpha)))
         (set-frame-parameter
          nil 'alpha
          (if (eql (cond ((numberp alpha) alpha)
                         ((numberp (cdr alpha)) (cdr alpha))
                         ;; Also handle undocumented (<active> <inactive>) form.
                         ((numberp (cadr alpha)) (cadr alpha)))
                   100)
              '(70 . 70) '(100 . 100)))))

   #+END_SRC
